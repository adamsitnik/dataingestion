using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace Microsoft.Extensions.DataIngestion.Tests
{
    public abstract class DocumentReaderConformanceTests
    {
        protected abstract DocumentReader CreateDocumentReader();

        public static IEnumerable<object[]> Sources
        {
            get
            {
                yield return new object[] { "https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-NRBF/%5bMS-NRBF%5d-190313.pdf" }; // PDF file
                yield return new object[] { "https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-NRBF/%5bMS-NRBF%5d-190313.docx" }; // DOCX file
                yield return new object[] { "https://www.bondcap.com/report/pdf/Trends_Artificial_Intelligence.pdf" }; // PDF file
            }
        }

        protected virtual void SimpleAsserts(Document document, string source)
        {
            Assert.NotNull(document);
            Assert.NotEmpty(document.Sections);
            Assert.NotEmpty(document.Markdown);

            var elements = Flatten(document).ToArray();
            Assert.Contains(elements, element => element is Header);
            Assert.Contains(elements, element => element is Paragraph);
            Assert.Contains(elements, element => element is Table);
            Assert.All(elements, element => Assert.NotEmpty(element.Markdown));
        }

        [Theory]
        [MemberData(nameof(Sources))]
        public async Task SupportsUris(string uri)
        {
            var reader = CreateDocumentReader();
            var document = await reader.ReadAsync(new Uri(uri));

            SimpleAsserts(document, uri);
        }

        public static IEnumerable<object[]> Files
        {
            get
            {
                // One page document with a table, header, and footer and few paragraph.
                // Generated by Copilot from Microsoft Word.
                yield return new object[] { Path.Combine("TestFiles", "Sample.pdf") };
                yield return new object[] { Path.Combine("TestFiles", "Sample.docx") };
            }
        }

        [Theory]
        [MemberData(nameof(Files))]
        public async Task SupportsFiles(string filePath)
        {
            var reader = CreateDocumentReader();
            var document = await reader.ReadAsync(filePath);

            SimpleAsserts(document, filePath);
        }

        [Fact]
        public async Task ThrowsIfCancellationRequestedUrl()
        {
            var reader = CreateDocumentReader();
            using CancellationTokenSource cts = new();
            cts.Cancel();

            await Assert.ThrowsAsync<OperationCanceledException>(async () => await reader.ReadAsync(new Uri("https://www.microsoft.com/"), cts.Token));
        }

        [Fact]
        public async Task ThrowsIfCancellationRequested()
        {
            string filePath = Path.Combine(Path.GetTempPath(), Path.GetTempFileName() + ".txt");
            await File.WriteAllTextAsync(filePath, "This is a test file for cancellation token.");

            var reader = CreateDocumentReader();
            using CancellationTokenSource cts = new();
            cts.Cancel();

            try
            {
                await Assert.ThrowsAsync<OperationCanceledException>(async () => await reader.ReadAsync(filePath, cts.Token)); // File path

                using (FileStream stream = File.OpenRead(filePath))
                {
                    await Assert.ThrowsAsync<OperationCanceledException>(async () => await reader.ReadAsync(stream, cts.Token)); // Stream
                }
            }
            finally
            {
                File.Delete(filePath);
            }
        }

        protected static IEnumerable<Element> Flatten(Document document)
        {
            Queue<Section> sectionsQueue = new(document.Sections);
            while (sectionsQueue.Count > 0)
            {
                Section section = sectionsQueue.Dequeue();
                foreach (Element element in section.Elements)
                {
                    // Please keep in mind that we don't preserve the order!
                    if (element is Section subSection)
                    {
                        sectionsQueue.Enqueue(subSection);
                    }
                    else
                    {
                        yield return element;
                    }
                }
            }
        }
    }
}
