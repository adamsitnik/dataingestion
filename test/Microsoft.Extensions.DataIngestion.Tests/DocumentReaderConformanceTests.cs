// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Xunit;

namespace Microsoft.Extensions.DataIngestion.Tests;

public abstract class DocumentReaderConformanceTests
{
    protected abstract DocumentReader CreateDocumentReader(bool extractImages = false);

    public static IEnumerable<object[]> Sources
    {
        get
        {
            yield return new object[] { "https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-NRBF/%5bMS-NRBF%5d-190313.pdf" }; // PDF file
            yield return new object[] { "https://winprotocoldocs-bhdugrdyduf5h2e4.b02.azurefd.net/MS-NRBF/%5bMS-NRBF%5d-190313.docx" }; // DOCX file
            yield return new object[] { "https://www.bondcap.com/report/pdf/Trends_Artificial_Intelligence.pdf" }; // PDF file (presentation)
        }
    }

    protected virtual void SimpleAsserts(IngestionDocument document, string source, string expectedId)
    {
        Assert.NotNull(document);
        Assert.Equal(expectedId, document.Identifier);
        Assert.NotEmpty(document.Sections);

        var elements = document.EnumerateContent().ToArray();
        Assert.Contains(elements, element => element is IngestionDocumentHeader);
        Assert.Contains(elements, element => element is IngestionDocumentParagraph);
        Assert.Contains(elements, element => element is IngestionDocumentTable);
        Assert.All(elements.Where(element => element is not IngestionDocumentImage), element => Assert.NotEmpty(element.GetMarkdown()));
    }

    [Theory]
    [MemberData(nameof(Sources))]
    public virtual async Task SupportsUris(string uri)
    {
        var reader = CreateDocumentReader();
        var document = await reader.ReadAsync(new Uri(uri));

        SimpleAsserts(document, uri, uri);
    }

    public static IEnumerable<object[]> Files
    {
        get
        {
            // One page document with a table, header, and footer and few paragraph.
            // Generated by Copilot from Microsoft Word.
            yield return new object[] { Path.Combine("TestFiles", "Sample.pdf") };
            yield return new object[] { Path.Combine("TestFiles", "Sample.docx") };
        }
    }

    [Theory]
    [MemberData(nameof(Files))]
    public virtual async Task SupportsFiles(string filePath)
    {
        var reader = CreateDocumentReader();
        var document = await reader.ReadAsync(filePath);

        SimpleAsserts(document, filePath, filePath);
    }

    [Fact]
    public virtual Task SupportsTables() => SupportsTablesCore(Path.Combine("TestFiles", "Sample.docx"));

    protected async Task SupportsTablesCore(string filePath)
    {
        var reader = CreateDocumentReader();
        var document = await reader.ReadAsync(filePath);

        IngestionDocumentTable documentTable = Assert.Single(document.EnumerateContent().OfType<IngestionDocumentTable>());
        Assert.Equal(5, documentTable.Cells.GetLength(0));
        Assert.Equal(4, documentTable.Cells.GetLength(1));

        string[,] expected =
        {
            { "Milestone", "Target Date", "Department", "Indicator" },
            { "Environmental Audit", "Mar 2025", "Environmental", "Audit Complete" },
            { "Renewable Energy Launch", "Jul 2025", "Facilities", "Install Operational" },
            { "Staff Workshop", "Sep 2025", "HR", "Workshop Held" },
            { "Emissions Review", "Dec 2029", "All", "25% Emissions Cut" }
        };

        Assert.Equal(expected, documentTable.Cells.Map(element => NormalizeCell(element)));
    }

    [Fact]
    public virtual Task SupportsTablesWithImages()
        => SupportsTablesWithImagesCore(Path.Combine("TestFiles", "TableWithImage.docx"));

    protected async Task<IngestionDocumentTable> SupportsTablesWithImagesCore(string filePath)
    {
        var reader = CreateDocumentReader(extractImages: true);
        var document = await reader.ReadAsync(filePath);

        var table = Assert.Single(document.EnumerateContent().OfType<IngestionDocumentTable>());
        Assert.Equal(5, table.Cells.GetLength(0));
        Assert.Equal(2, table.Cells.GetLength(1));

        // Each reader properly recognizes the text from the first column.
        // When it comes to the images, MarkItDown extracts them as images, while
        // other readers return nothing or ORCed text.
        Assert.Equal("Years", NormalizeCell(table.Cells[0, 0]));
        Assert.Equal("2020-2025", NormalizeCell(table.Cells[1, 0]));
        Assert.Equal("2015-2020", NormalizeCell(table.Cells[2, 0]));
        Assert.Equal("2010-2015", NormalizeCell(table.Cells[3, 0]));
        Assert.Equal("2000-2010", NormalizeCell(table.Cells[4, 0]));

        return table;
    }

    private string? NormalizeCell(IngestionDocumentElement? ingestionDocumentElement)
    {
        Assert.NotNull(ingestionDocumentElement);

        // Some readers add extra spaces or asterisks for bold/italic text for headers.
        return ingestionDocumentElement.GetMarkdown().Trim().Trim('*');
    }

    public static IEnumerable<object[]> Images
    {
        get
        {
            // One page document with an Image generated by Microsoft Copilot.
            yield return new object[] { Path.Combine("TestFiles", "SampleWithImage.pdf") };
        }
    }

    [Theory]
    [MemberData(nameof(Images))]
    public virtual async Task SupportsImages(string filePath)
    {
        var reader = CreateDocumentReader(extractImages: true);
        var document = await reader.ReadAsync(filePath);

        SimpleAsserts(document, filePath, filePath);
        var elements = document.EnumerateContent().ToArray();
        Assert.Contains(elements, element => element is IngestionDocumentImage img && img.Content.HasValue && !string.IsNullOrEmpty(img.MediaType));
    }

    [Fact]
    public async Task ThrowsWhenIdentifierIsNotProvided()
    {
        var reader = CreateDocumentReader();

        await Assert.ThrowsAsync<ArgumentNullException>(async () => await reader.ReadAsync(new Uri("https://www.microsoft.com/"), identifier: null!));
        await Assert.ThrowsAsync<ArgumentNullException>(async () => await reader.ReadAsync(new Uri("https://www.microsoft.com/"), identifier: string.Empty));
        await Assert.ThrowsAsync<ArgumentNullException>(async () => await reader.ReadAsync("fileName.txt", identifier: null!));
        await Assert.ThrowsAsync<ArgumentNullException>(async () => await reader.ReadAsync("fileName.txt", identifier: string.Empty));
    }

    [Fact]
    public async Task ThrowsIfCancellationRequestedUrl()
    {
        var reader = CreateDocumentReader();
        using CancellationTokenSource cts = new();
        cts.Cancel();

        await Assert.ThrowsAsync<TaskCanceledException>(async () => await reader.ReadAsync(new Uri("https://www.microsoft.com/"), cts.Token));
    }

    [Fact]
    public async Task ThrowsIfCancellationRequested()
    {
        string filePath = Path.Combine(Path.GetTempPath(), Path.GetTempFileName() + ".txt");
        await File.WriteAllTextAsync(filePath, "This is a test file for cancellation token.");

        var reader = CreateDocumentReader();
        using CancellationTokenSource cts = new();
        cts.Cancel();

        try
        {
            await Assert.ThrowsAsync<TaskCanceledException>(async () => await reader.ReadAsync(filePath, cts.Token)); // File path
        }
        finally
        {
            File.Delete(filePath);
        }
    }
}
